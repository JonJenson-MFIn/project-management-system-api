// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/JonJenson-MFIn/project-management-system-api/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Auth func(ctx context.Context, obj any, next graphql.Resolver, role model.Role) (res any, err error)
}

type ComplexityRoot struct {
	Employee struct {
		Active          func(childComplexity int) int
		Email           func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		ProjectAssigned func(childComplexity int) int
		Role            func(childComplexity int) int
	}

	Mutation struct {
		AddEmployee          func(childComplexity int, input model.EmployeeInput) int
		AddNotification      func(childComplexity int, message string, employeeID string) int
		AddProject           func(childComplexity int, input model.ProjectInput) int
		AddTask              func(childComplexity int, input model.TaskInput) int
		AddTeam              func(childComplexity int, input model.TeamInput) int
		AddTicket            func(childComplexity int, input model.TicketInput) int
		DeleteEmployee       func(childComplexity int, id string) int
		DeleteProject        func(childComplexity int, id string) int
		DeleteTask           func(childComplexity int, id string) int
		DeleteTeam           func(childComplexity int, id string) int
		DeleteTicket         func(childComplexity int, id string) int
		MarkNotificationRead func(childComplexity int, id string) int
		UpdateEmployee       func(childComplexity int, id string, input model.EmployeeInput) int
		UpdateProject        func(childComplexity int, id string, input model.ProjectInput) int
		UpdateTask           func(childComplexity int, id string, input model.TaskInput) int
		UpdateTeam           func(childComplexity int, id string, input model.TeamInput) int
		UpdateTicket         func(childComplexity int, id string, input model.TicketInput) int
	}

	Notification struct {
		CreatedAt func(childComplexity int) int
		Employee  func(childComplexity int) int
		ID        func(childComplexity int) int
		Message   func(childComplexity int) int
		Read      func(childComplexity int) int
	}

	Project struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Manager     func(childComplexity int) int
		Name        func(childComplexity int) int
		StartDate   func(childComplexity int) int
		Status      func(childComplexity int) int
		Teams       func(childComplexity int) int
		Tickets     func(childComplexity int) int
	}

	Query struct {
		Employee      func(childComplexity int, id string) int
		Employees     func(childComplexity int) int
		Notifications func(childComplexity int, employeeID string) int
		Project       func(childComplexity int, id string) int
		Projects      func(childComplexity int) int
		SignIn        func(childComplexity int, email string, password string) int
		Task          func(childComplexity int, id string) int
		Tasks         func(childComplexity int) int
		Team          func(childComplexity int, id string) int
		Teams         func(childComplexity int) int
		Ticket        func(childComplexity int, id string) int
		Tickets       func(childComplexity int) int
	}

	Task struct {
		AssignedTo  func(childComplexity int) int
		CompletedAt func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		DueDate     func(childComplexity int) int
		ID          func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
	}

	Team struct {
		Engineers  func(childComplexity int) int
		ID         func(childComplexity int) int
		TeamLeader func(childComplexity int) int
	}

	Ticket struct {
		CompletedAt func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Project     func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Employee.active":
		if e.complexity.Employee.Active == nil {
			break
		}

		return e.complexity.Employee.Active(childComplexity), true

	case "Employee.email":
		if e.complexity.Employee.Email == nil {
			break
		}

		return e.complexity.Employee.Email(childComplexity), true

	case "Employee.id":
		if e.complexity.Employee.ID == nil {
			break
		}

		return e.complexity.Employee.ID(childComplexity), true

	case "Employee.name":
		if e.complexity.Employee.Name == nil {
			break
		}

		return e.complexity.Employee.Name(childComplexity), true

	case "Employee.project_assigned":
		if e.complexity.Employee.ProjectAssigned == nil {
			break
		}

		return e.complexity.Employee.ProjectAssigned(childComplexity), true

	case "Employee.role":
		if e.complexity.Employee.Role == nil {
			break
		}

		return e.complexity.Employee.Role(childComplexity), true

	case "Mutation.addEmployee":
		if e.complexity.Mutation.AddEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_addEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEmployee(childComplexity, args["input"].(model.EmployeeInput)), true

	case "Mutation.addNotification":
		if e.complexity.Mutation.AddNotification == nil {
			break
		}

		args, err := ec.field_Mutation_addNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNotification(childComplexity, args["message"].(string), args["employeeID"].(string)), true

	case "Mutation.addProject":
		if e.complexity.Mutation.AddProject == nil {
			break
		}

		args, err := ec.field_Mutation_addProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProject(childComplexity, args["input"].(model.ProjectInput)), true

	case "Mutation.addTask":
		if e.complexity.Mutation.AddTask == nil {
			break
		}

		args, err := ec.field_Mutation_addTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTask(childComplexity, args["input"].(model.TaskInput)), true

	case "Mutation.addTeam":
		if e.complexity.Mutation.AddTeam == nil {
			break
		}

		args, err := ec.field_Mutation_addTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTeam(childComplexity, args["input"].(model.TeamInput)), true

	case "Mutation.addTicket":
		if e.complexity.Mutation.AddTicket == nil {
			break
		}

		args, err := ec.field_Mutation_addTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTicket(childComplexity, args["input"].(model.TicketInput)), true

	case "Mutation.deleteEmployee":
		if e.complexity.Mutation.DeleteEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEmployee(childComplexity, args["id"].(string)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["id"].(string)), true

	case "Mutation.deleteTask":
		if e.complexity.Mutation.DeleteTask == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTask(childComplexity, args["id"].(string)), true

	case "Mutation.deleteTeam":
		if e.complexity.Mutation.DeleteTeam == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTeam(childComplexity, args["id"].(string)), true

	case "Mutation.deleteTicket":
		if e.complexity.Mutation.DeleteTicket == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTicket(childComplexity, args["id"].(string)), true

	case "Mutation.markNotificationRead":
		if e.complexity.Mutation.MarkNotificationRead == nil {
			break
		}

		args, err := ec.field_Mutation_markNotificationRead_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarkNotificationRead(childComplexity, args["id"].(string)), true

	case "Mutation.updateEmployee":
		if e.complexity.Mutation.UpdateEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_updateEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEmployee(childComplexity, args["id"].(string), args["input"].(model.EmployeeInput)), true

	case "Mutation.updateProject":
		if e.complexity.Mutation.UpdateProject == nil {
			break
		}

		args, err := ec.field_Mutation_updateProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProject(childComplexity, args["id"].(string), args["input"].(model.ProjectInput)), true

	case "Mutation.updateTask":
		if e.complexity.Mutation.UpdateTask == nil {
			break
		}

		args, err := ec.field_Mutation_updateTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTask(childComplexity, args["id"].(string), args["input"].(model.TaskInput)), true

	case "Mutation.updateTeam":
		if e.complexity.Mutation.UpdateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_updateTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeam(childComplexity, args["id"].(string), args["input"].(model.TeamInput)), true

	case "Mutation.updateTicket":
		if e.complexity.Mutation.UpdateTicket == nil {
			break
		}

		args, err := ec.field_Mutation_updateTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTicket(childComplexity, args["id"].(string), args["input"].(model.TicketInput)), true

	case "Notification.createdAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.employee":
		if e.complexity.Notification.Employee == nil {
			break
		}

		return e.complexity.Notification.Employee(childComplexity), true

	case "Notification.id":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.message":
		if e.complexity.Notification.Message == nil {
			break
		}

		return e.complexity.Notification.Message(childComplexity), true

	case "Notification.read":
		if e.complexity.Notification.Read == nil {
			break
		}

		return e.complexity.Notification.Read(childComplexity), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.manager":
		if e.complexity.Project.Manager == nil {
			break
		}

		return e.complexity.Project.Manager(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.startDate":
		if e.complexity.Project.StartDate == nil {
			break
		}

		return e.complexity.Project.StartDate(childComplexity), true

	case "Project.status":
		if e.complexity.Project.Status == nil {
			break
		}

		return e.complexity.Project.Status(childComplexity), true

	case "Project.teams":
		if e.complexity.Project.Teams == nil {
			break
		}

		return e.complexity.Project.Teams(childComplexity), true

	case "Project.tickets":
		if e.complexity.Project.Tickets == nil {
			break
		}

		return e.complexity.Project.Tickets(childComplexity), true

	case "Query.employee":
		if e.complexity.Query.Employee == nil {
			break
		}

		args, err := ec.field_Query_employee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Employee(childComplexity, args["id"].(string)), true

	case "Query.employees":
		if e.complexity.Query.Employees == nil {
			break
		}

		return e.complexity.Query.Employees(childComplexity), true

	case "Query.notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		args, err := ec.field_Query_notifications_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Notifications(childComplexity, args["employeeID"].(string)), true

	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["id"].(string)), true

	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		return e.complexity.Query.Projects(childComplexity), true

	case "Query.signIn":
		if e.complexity.Query.SignIn == nil {
			break
		}

		args, err := ec.field_Query_signIn_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SignIn(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		args, err := ec.field_Query_task_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Task(childComplexity, args["id"].(string)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		return e.complexity.Query.Tasks(childComplexity), true

	case "Query.team":
		if e.complexity.Query.Team == nil {
			break
		}

		args, err := ec.field_Query_team_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Team(childComplexity, args["id"].(string)), true

	case "Query.teams":
		if e.complexity.Query.Teams == nil {
			break
		}

		return e.complexity.Query.Teams(childComplexity), true

	case "Query.ticket":
		if e.complexity.Query.Ticket == nil {
			break
		}

		args, err := ec.field_Query_ticket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Ticket(childComplexity, args["id"].(string)), true

	case "Query.tickets":
		if e.complexity.Query.Tickets == nil {
			break
		}

		return e.complexity.Query.Tickets(childComplexity), true

	case "Task.assignedTo":
		if e.complexity.Task.AssignedTo == nil {
			break
		}

		return e.complexity.Task.AssignedTo(childComplexity), true

	case "Task.completedAt":
		if e.complexity.Task.CompletedAt == nil {
			break
		}

		return e.complexity.Task.CompletedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.description":
		if e.complexity.Task.Description == nil {
			break
		}

		return e.complexity.Task.Description(childComplexity), true

	case "Task.dueDate":
		if e.complexity.Task.DueDate == nil {
			break
		}

		return e.complexity.Task.DueDate(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.title":
		if e.complexity.Task.Title == nil {
			break
		}

		return e.complexity.Task.Title(childComplexity), true

	case "Team.engineers":
		if e.complexity.Team.Engineers == nil {
			break
		}

		return e.complexity.Team.Engineers(childComplexity), true

	case "Team.id":
		if e.complexity.Team.ID == nil {
			break
		}

		return e.complexity.Team.ID(childComplexity), true

	case "Team.teamLeader":
		if e.complexity.Team.TeamLeader == nil {
			break
		}

		return e.complexity.Team.TeamLeader(childComplexity), true

	case "Ticket.completedAt":
		if e.complexity.Ticket.CompletedAt == nil {
			break
		}

		return e.complexity.Ticket.CompletedAt(childComplexity), true

	case "Ticket.createdAt":
		if e.complexity.Ticket.CreatedAt == nil {
			break
		}

		return e.complexity.Ticket.CreatedAt(childComplexity), true

	case "Ticket.description":
		if e.complexity.Ticket.Description == nil {
			break
		}

		return e.complexity.Ticket.Description(childComplexity), true

	case "Ticket.id":
		if e.complexity.Ticket.ID == nil {
			break
		}

		return e.complexity.Ticket.ID(childComplexity), true

	case "Ticket.project":
		if e.complexity.Ticket.Project == nil {
			break
		}

		return e.complexity.Ticket.Project(childComplexity), true

	case "Ticket.status":
		if e.complexity.Ticket.Status == nil {
			break
		}

		return e.complexity.Ticket.Status(childComplexity), true

	case "Ticket.title":
		if e.complexity.Ticket.Title == nil {
			break
		}

		return e.complexity.Ticket.Title(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputEmployeeInput,
		ec.unmarshalInputLoginDetailsInput,
		ec.unmarshalInputProjectInput,
		ec.unmarshalInputTaskInput,
		ec.unmarshalInputTeamInput,
		ec.unmarshalInputTicketInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../graphqls/mutations.graphqls", Input: `# ----------- Mutations -----------

type Mutation {
  addEmployee(input: EmployeeInput!): Employee!
  updateEmployee(id: ID!, input: EmployeeInput!): Employee!
  deleteEmployee(id: ID!): Boolean!  @auth(role: ADMIN)

  addProject(input: ProjectInput!): Project!
  updateProject(id: ID!, input: ProjectInput!): Project!
  deleteProject(id: ID!): Boolean!

  addTeam(input: TeamInput!): Team!
  updateTeam(id: ID!, input: TeamInput!): Team!
  deleteTeam(id: ID!): Boolean!

  addTicket(input: TicketInput!): Ticket!
  updateTicket(id: ID!, input: TicketInput!): Ticket!
  deleteTicket(id: ID!): Boolean!

  addTask(input: TaskInput!): Task!
  updateTask(id: ID!, input: TaskInput!): Task!
  deleteTask(id: ID!): Boolean!

  addNotification(message: String!, employeeID: ID!): Notification!
  markNotificationRead(id: ID!): Boolean!
}
`, BuiltIn: false},
	{Name: "../graphqls/query.graphqls", Input: `# ----------- Queries -----------

type Query {
  employees: [Employee!]!
  employee(id: ID!): Employee
  signIn(email:String!,password:String!):Boolean!

  projects: [Project!]!
  project(id: ID!): Project

  tasks: [Task!]!
  task(id: ID!): Task

  tickets: [Ticket!]!
  ticket(id: ID!): Ticket

  teams: [Team!]!
  team(id: ID!): Team

  notifications(employeeID: ID!): [Notification!]!
}`, BuiltIn: false},
	{Name: "../graphqls/types.graphqls", Input: `# ----------- Scalars -----------
scalar Date
scalar DateTime

# ----------- Enums -----------
enum Role {
  ADMIN
  EMPLOYEE
  TL
  MANAGER
}

# ---------- Directive -----------

directive @auth(role: Role!) on FIELD_DEFINITION

enum Status {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  ON_HOLD
  CANCELLED
}

# ----------- Types -----------

type Employee {
  id: ID!
  name: String!
  email:String!
  role: Role!
  active: Boolean!
  project_assigned: Project
}

type Project {
  id: ID!
  manager: Employee
  teams: [Team!]
  name: String!
  status: Status!
  tickets: [Ticket!]
  description: String
  startDate: DateTime!
}

type Team {
  id: ID!
  teamLeader: Employee
  engineers: [Employee!]
}

type Ticket {
  id: ID!
  status: Status!
  title: String!
  description: String
  createdAt: DateTime!
  completedAt: DateTime
  project: Project!
}

type Task {
  id: ID!
  title: String!
  description: String
  assignedTo: Employee!
  dueDate: Date
  status: Status!
  createdAt: DateTime!
  completedAt: DateTime
}

type Notification {
  id: ID!
  message: String!
  employee: Employee!
  createdAt: DateTime!
  read: Boolean!
}

# ----------- Inputs -----------

input LoginDetailsInput {
  username: String!
  password: String!
}

input EmployeeInput {
  name: String!
  role: Role!
  email:String!
  password:String
  projectID: ID
}

input ProjectInput {
  name: String!
  managerID: ID
  teamIDs: [ID!]
  status: Status
  description: String
}

input TeamInput {
  teamLeaderID: ID!
  engineerIDs: [ID!]!
}

input TicketInput {
  title: String!
  description: String
  projectID: ID!
  status: Status!
}

input TaskInput {
  title: String!
  description: String
  assignedToID: ID
  dueDate: Date
  status: Status!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
