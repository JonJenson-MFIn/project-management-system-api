// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/JonJenson-MFIn/project-management-system-api/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Auth      func(ctx context.Context, obj any, next graphql.Resolver, role model.Role) (res any, err error)
	Cache     func(ctx context.Context, obj any, next graphql.Resolver, ttl int) (res any, err error)
	RateLimit func(ctx context.Context, obj any, next graphql.Resolver, limit int, window string) (res any, err error)
}

type ComplexityRoot struct {
	Employee struct {
		Active            func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Email             func(childComplexity int) int
		ID                func(childComplexity int) int
		Name              func(childComplexity int) int
		ProjectAssignedID func(childComplexity int) int
		Role              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	Mutation struct {
		AddEmployee               func(childComplexity int, input model.EmployeeInput) int
		AddNotification           func(childComplexity int, message string, employeeID int, typeArg *model.NotificationType) int
		AddProject                func(childComplexity int, input model.ProjectInput) int
		AddProjectEmployee        func(childComplexity int, input model.ProjectEmployeeInput) int
		AddProjectTeam            func(childComplexity int, input model.ProjectTeamInput) int
		AddTask                   func(childComplexity int, input model.TaskInput) int
		AddTeam                   func(childComplexity int, input model.TeamInput) int
		AddTeamEngineer           func(childComplexity int, input model.TeamEngineerInput) int
		AddTicket                 func(childComplexity int, input model.TicketInput) int
		DeleteEmployee            func(childComplexity int, id int) int
		DeleteProject             func(childComplexity int, id int) int
		DeleteTask                func(childComplexity int, id int) int
		DeleteTeam                func(childComplexity int, id int) int
		DeleteTicket              func(childComplexity int, id int) int
		MarkNotificationRead      func(childComplexity int, id int) int
		RemoveProjectEmployee     func(childComplexity int, input model.ProjectEmployeeInput) int
		RemoveProjectTeam         func(childComplexity int, input model.ProjectTeamInput) int
		RemoveTeamEngineer        func(childComplexity int, input model.TeamEngineerInput) int
		UpdateEmployee            func(childComplexity int, id int, input model.EmployeeInput) int
		UpdateProject             func(childComplexity int, id int, input model.ProjectInput) int
		UpdateProjectEmployeeRole func(childComplexity int, input model.ProjectEmployeeInput) int
		UpdateTask                func(childComplexity int, id int, input model.TaskInput) int
		UpdateTeam                func(childComplexity int, id int, input model.TeamInput) int
		UpdateTicket              func(childComplexity int, id int, input model.TicketInput) int
	}

	Notification struct {
		CreatedAt  func(childComplexity int) int
		EmployeeID func(childComplexity int) int
		ID         func(childComplexity int) int
		Message    func(childComplexity int) int
		Read       func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	Project struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		ManagerID   func(childComplexity int) int
		Name        func(childComplexity int) int
		StartDate   func(childComplexity int) int
		Status      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	ProjectEmployee struct {
		CreatedAt  func(childComplexity int) int
		EmployeeID func(childComplexity int) int
		ProjectID  func(childComplexity int) int
		Role       func(childComplexity int) int
	}

	ProjectTeam struct {
		CreatedAt func(childComplexity int) int
		ProjectID func(childComplexity int) int
		TeamID    func(childComplexity int) int
	}

	Query struct {
		Employee           func(childComplexity int, id int) int
		Employees          func(childComplexity int, filter *model.EmployeeFilter) int
		EmployeesByProject func(childComplexity int, projectID int) int
		EngineersByTeam    func(childComplexity int, teamID int) int
		Notifications      func(childComplexity int, employeeID int, filter *model.NotificationFilter) int
		Project            func(childComplexity int, id int) int
		ProjectEmployees   func(childComplexity int, projectID int) int
		ProjectTeams       func(childComplexity int, projectID int) int
		Projects           func(childComplexity int, filter *model.ProjectFilter) int
		SignIn             func(childComplexity int, email string, password string) int
		Task               func(childComplexity int, id int) int
		Tasks              func(childComplexity int, filter *model.TaskFilter) int
		Team               func(childComplexity int, id int) int
		TeamEngineers      func(childComplexity int, teamID int) int
		Teams              func(childComplexity int, filter *model.TeamFilter) int
		TeamsByProject     func(childComplexity int, projectID int) int
		Ticket             func(childComplexity int, id int) int
		Tickets            func(childComplexity int, filter *model.TicketFilter) int
	}

	Task struct {
		AssignedToID func(childComplexity int) int
		CompletedAt  func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		DueDate      func(childComplexity int) int
		ID           func(childComplexity int) int
		Priority     func(childComplexity int) int
		ProjectID    func(childComplexity int) int
		Status       func(childComplexity int) int
		Title        func(childComplexity int) int
	}

	Team struct {
		CreatedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		TeamLeaderID func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	TeamEngineer struct {
		CreatedAt  func(childComplexity int) int
		EngineerID func(childComplexity int) int
		TeamID     func(childComplexity int) int
	}

	Ticket struct {
		AssignedToID func(childComplexity int) int
		CompletedAt  func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		Priority     func(childComplexity int) int
		ProjectID    func(childComplexity int) int
		Status       func(childComplexity int) int
		Title        func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Employee.active":
		if e.complexity.Employee.Active == nil {
			break
		}

		return e.complexity.Employee.Active(childComplexity), true

	case "Employee.createdAt":
		if e.complexity.Employee.CreatedAt == nil {
			break
		}

		return e.complexity.Employee.CreatedAt(childComplexity), true

	case "Employee.email":
		if e.complexity.Employee.Email == nil {
			break
		}

		return e.complexity.Employee.Email(childComplexity), true

	case "Employee.id":
		if e.complexity.Employee.ID == nil {
			break
		}

		return e.complexity.Employee.ID(childComplexity), true

	case "Employee.name":
		if e.complexity.Employee.Name == nil {
			break
		}

		return e.complexity.Employee.Name(childComplexity), true

	case "Employee.projectAssignedID":
		if e.complexity.Employee.ProjectAssignedID == nil {
			break
		}

		return e.complexity.Employee.ProjectAssignedID(childComplexity), true

	case "Employee.role":
		if e.complexity.Employee.Role == nil {
			break
		}

		return e.complexity.Employee.Role(childComplexity), true

	case "Employee.updatedAt":
		if e.complexity.Employee.UpdatedAt == nil {
			break
		}

		return e.complexity.Employee.UpdatedAt(childComplexity), true

	case "Mutation.addEmployee":
		if e.complexity.Mutation.AddEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_addEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddEmployee(childComplexity, args["input"].(model.EmployeeInput)), true

	case "Mutation.addNotification":
		if e.complexity.Mutation.AddNotification == nil {
			break
		}

		args, err := ec.field_Mutation_addNotification_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNotification(childComplexity, args["message"].(string), args["employeeID"].(int), args["type"].(*model.NotificationType)), true

	case "Mutation.addProject":
		if e.complexity.Mutation.AddProject == nil {
			break
		}

		args, err := ec.field_Mutation_addProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProject(childComplexity, args["input"].(model.ProjectInput)), true

	case "Mutation.addProjectEmployee":
		if e.complexity.Mutation.AddProjectEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectEmployee(childComplexity, args["input"].(model.ProjectEmployeeInput)), true

	case "Mutation.addProjectTeam":
		if e.complexity.Mutation.AddProjectTeam == nil {
			break
		}

		args, err := ec.field_Mutation_addProjectTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddProjectTeam(childComplexity, args["input"].(model.ProjectTeamInput)), true

	case "Mutation.addTask":
		if e.complexity.Mutation.AddTask == nil {
			break
		}

		args, err := ec.field_Mutation_addTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTask(childComplexity, args["input"].(model.TaskInput)), true

	case "Mutation.addTeam":
		if e.complexity.Mutation.AddTeam == nil {
			break
		}

		args, err := ec.field_Mutation_addTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTeam(childComplexity, args["input"].(model.TeamInput)), true

	case "Mutation.addTeamEngineer":
		if e.complexity.Mutation.AddTeamEngineer == nil {
			break
		}

		args, err := ec.field_Mutation_addTeamEngineer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTeamEngineer(childComplexity, args["input"].(model.TeamEngineerInput)), true

	case "Mutation.addTicket":
		if e.complexity.Mutation.AddTicket == nil {
			break
		}

		args, err := ec.field_Mutation_addTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTicket(childComplexity, args["input"].(model.TicketInput)), true

	case "Mutation.deleteEmployee":
		if e.complexity.Mutation.DeleteEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEmployee(childComplexity, args["id"].(int)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTask":
		if e.complexity.Mutation.DeleteTask == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTask(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTeam":
		if e.complexity.Mutation.DeleteTeam == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTeam(childComplexity, args["id"].(int)), true

	case "Mutation.deleteTicket":
		if e.complexity.Mutation.DeleteTicket == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTicket(childComplexity, args["id"].(int)), true

	case "Mutation.markNotificationRead":
		if e.complexity.Mutation.MarkNotificationRead == nil {
			break
		}

		args, err := ec.field_Mutation_markNotificationRead_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MarkNotificationRead(childComplexity, args["id"].(int)), true

	case "Mutation.removeProjectEmployee":
		if e.complexity.Mutation.RemoveProjectEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_removeProjectEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveProjectEmployee(childComplexity, args["input"].(model.ProjectEmployeeInput)), true

	case "Mutation.removeProjectTeam":
		if e.complexity.Mutation.RemoveProjectTeam == nil {
			break
		}

		args, err := ec.field_Mutation_removeProjectTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveProjectTeam(childComplexity, args["input"].(model.ProjectTeamInput)), true

	case "Mutation.removeTeamEngineer":
		if e.complexity.Mutation.RemoveTeamEngineer == nil {
			break
		}

		args, err := ec.field_Mutation_removeTeamEngineer_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveTeamEngineer(childComplexity, args["input"].(model.TeamEngineerInput)), true

	case "Mutation.updateEmployee":
		if e.complexity.Mutation.UpdateEmployee == nil {
			break
		}

		args, err := ec.field_Mutation_updateEmployee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEmployee(childComplexity, args["id"].(int), args["input"].(model.EmployeeInput)), true

	case "Mutation.updateProject":
		if e.complexity.Mutation.UpdateProject == nil {
			break
		}

		args, err := ec.field_Mutation_updateProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProject(childComplexity, args["id"].(int), args["input"].(model.ProjectInput)), true

	case "Mutation.updateProjectEmployeeRole":
		if e.complexity.Mutation.UpdateProjectEmployeeRole == nil {
			break
		}

		args, err := ec.field_Mutation_updateProjectEmployeeRole_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProjectEmployeeRole(childComplexity, args["input"].(model.ProjectEmployeeInput)), true

	case "Mutation.updateTask":
		if e.complexity.Mutation.UpdateTask == nil {
			break
		}

		args, err := ec.field_Mutation_updateTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTask(childComplexity, args["id"].(int), args["input"].(model.TaskInput)), true

	case "Mutation.updateTeam":
		if e.complexity.Mutation.UpdateTeam == nil {
			break
		}

		args, err := ec.field_Mutation_updateTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTeam(childComplexity, args["id"].(int), args["input"].(model.TeamInput)), true

	case "Mutation.updateTicket":
		if e.complexity.Mutation.UpdateTicket == nil {
			break
		}

		args, err := ec.field_Mutation_updateTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTicket(childComplexity, args["id"].(int), args["input"].(model.TicketInput)), true

	case "Notification.createdAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.employeeID":
		if e.complexity.Notification.EmployeeID == nil {
			break
		}

		return e.complexity.Notification.EmployeeID(childComplexity), true

	case "Notification.id":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.message":
		if e.complexity.Notification.Message == nil {
			break
		}

		return e.complexity.Notification.Message(childComplexity), true

	case "Notification.read":
		if e.complexity.Notification.Read == nil {
			break
		}

		return e.complexity.Notification.Read(childComplexity), true

	case "Notification.type":
		if e.complexity.Notification.Type == nil {
			break
		}

		return e.complexity.Notification.Type(childComplexity), true

	case "Project.createdAt":
		if e.complexity.Project.CreatedAt == nil {
			break
		}

		return e.complexity.Project.CreatedAt(childComplexity), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.managerID":
		if e.complexity.Project.ManagerID == nil {
			break
		}

		return e.complexity.Project.ManagerID(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.startDate":
		if e.complexity.Project.StartDate == nil {
			break
		}

		return e.complexity.Project.StartDate(childComplexity), true

	case "Project.status":
		if e.complexity.Project.Status == nil {
			break
		}

		return e.complexity.Project.Status(childComplexity), true

	case "Project.updatedAt":
		if e.complexity.Project.UpdatedAt == nil {
			break
		}

		return e.complexity.Project.UpdatedAt(childComplexity), true

	case "ProjectEmployee.createdAt":
		if e.complexity.ProjectEmployee.CreatedAt == nil {
			break
		}

		return e.complexity.ProjectEmployee.CreatedAt(childComplexity), true

	case "ProjectEmployee.employeeID":
		if e.complexity.ProjectEmployee.EmployeeID == nil {
			break
		}

		return e.complexity.ProjectEmployee.EmployeeID(childComplexity), true

	case "ProjectEmployee.projectID":
		if e.complexity.ProjectEmployee.ProjectID == nil {
			break
		}

		return e.complexity.ProjectEmployee.ProjectID(childComplexity), true

	case "ProjectEmployee.role":
		if e.complexity.ProjectEmployee.Role == nil {
			break
		}

		return e.complexity.ProjectEmployee.Role(childComplexity), true

	case "ProjectTeam.createdAt":
		if e.complexity.ProjectTeam.CreatedAt == nil {
			break
		}

		return e.complexity.ProjectTeam.CreatedAt(childComplexity), true

	case "ProjectTeam.projectID":
		if e.complexity.ProjectTeam.ProjectID == nil {
			break
		}

		return e.complexity.ProjectTeam.ProjectID(childComplexity), true

	case "ProjectTeam.teamID":
		if e.complexity.ProjectTeam.TeamID == nil {
			break
		}

		return e.complexity.ProjectTeam.TeamID(childComplexity), true

	case "Query.employee":
		if e.complexity.Query.Employee == nil {
			break
		}

		args, err := ec.field_Query_employee_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Employee(childComplexity, args["id"].(int)), true

	case "Query.employees":
		if e.complexity.Query.Employees == nil {
			break
		}

		args, err := ec.field_Query_employees_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Employees(childComplexity, args["filter"].(*model.EmployeeFilter)), true

	case "Query.employeesByProject":
		if e.complexity.Query.EmployeesByProject == nil {
			break
		}

		args, err := ec.field_Query_employeesByProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EmployeesByProject(childComplexity, args["projectID"].(int)), true

	case "Query.engineersByTeam":
		if e.complexity.Query.EngineersByTeam == nil {
			break
		}

		args, err := ec.field_Query_engineersByTeam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EngineersByTeam(childComplexity, args["teamID"].(int)), true

	case "Query.notifications":
		if e.complexity.Query.Notifications == nil {
			break
		}

		args, err := ec.field_Query_notifications_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Notifications(childComplexity, args["employeeID"].(int), args["filter"].(*model.NotificationFilter)), true

	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["id"].(int)), true

	case "Query.projectEmployees":
		if e.complexity.Query.ProjectEmployees == nil {
			break
		}

		args, err := ec.field_Query_projectEmployees_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectEmployees(childComplexity, args["projectID"].(int)), true

	case "Query.projectTeams":
		if e.complexity.Query.ProjectTeams == nil {
			break
		}

		args, err := ec.field_Query_projectTeams_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectTeams(childComplexity, args["projectID"].(int)), true

	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		args, err := ec.field_Query_projects_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Projects(childComplexity, args["filter"].(*model.ProjectFilter)), true

	case "Query.signIn":
		if e.complexity.Query.SignIn == nil {
			break
		}

		args, err := ec.field_Query_signIn_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SignIn(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		args, err := ec.field_Query_task_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Task(childComplexity, args["id"].(int)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		args, err := ec.field_Query_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tasks(childComplexity, args["filter"].(*model.TaskFilter)), true

	case "Query.team":
		if e.complexity.Query.Team == nil {
			break
		}

		args, err := ec.field_Query_team_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Team(childComplexity, args["id"].(int)), true

	case "Query.teamEngineers":
		if e.complexity.Query.TeamEngineers == nil {
			break
		}

		args, err := ec.field_Query_teamEngineers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TeamEngineers(childComplexity, args["teamID"].(int)), true

	case "Query.teams":
		if e.complexity.Query.Teams == nil {
			break
		}

		args, err := ec.field_Query_teams_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Teams(childComplexity, args["filter"].(*model.TeamFilter)), true

	case "Query.teamsByProject":
		if e.complexity.Query.TeamsByProject == nil {
			break
		}

		args, err := ec.field_Query_teamsByProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TeamsByProject(childComplexity, args["projectID"].(int)), true

	case "Query.ticket":
		if e.complexity.Query.Ticket == nil {
			break
		}

		args, err := ec.field_Query_ticket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Ticket(childComplexity, args["id"].(int)), true

	case "Query.tickets":
		if e.complexity.Query.Tickets == nil {
			break
		}

		args, err := ec.field_Query_tickets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tickets(childComplexity, args["filter"].(*model.TicketFilter)), true

	case "Task.assignedToID":
		if e.complexity.Task.AssignedToID == nil {
			break
		}

		return e.complexity.Task.AssignedToID(childComplexity), true

	case "Task.completedAt":
		if e.complexity.Task.CompletedAt == nil {
			break
		}

		return e.complexity.Task.CompletedAt(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.description":
		if e.complexity.Task.Description == nil {
			break
		}

		return e.complexity.Task.Description(childComplexity), true

	case "Task.dueDate":
		if e.complexity.Task.DueDate == nil {
			break
		}

		return e.complexity.Task.DueDate(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.priority":
		if e.complexity.Task.Priority == nil {
			break
		}

		return e.complexity.Task.Priority(childComplexity), true

	case "Task.projectID":
		if e.complexity.Task.ProjectID == nil {
			break
		}

		return e.complexity.Task.ProjectID(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.title":
		if e.complexity.Task.Title == nil {
			break
		}

		return e.complexity.Task.Title(childComplexity), true

	case "Team.createdAt":
		if e.complexity.Team.CreatedAt == nil {
			break
		}

		return e.complexity.Team.CreatedAt(childComplexity), true

	case "Team.description":
		if e.complexity.Team.Description == nil {
			break
		}

		return e.complexity.Team.Description(childComplexity), true

	case "Team.id":
		if e.complexity.Team.ID == nil {
			break
		}

		return e.complexity.Team.ID(childComplexity), true

	case "Team.name":
		if e.complexity.Team.Name == nil {
			break
		}

		return e.complexity.Team.Name(childComplexity), true

	case "Team.teamLeaderID":
		if e.complexity.Team.TeamLeaderID == nil {
			break
		}

		return e.complexity.Team.TeamLeaderID(childComplexity), true

	case "Team.updatedAt":
		if e.complexity.Team.UpdatedAt == nil {
			break
		}

		return e.complexity.Team.UpdatedAt(childComplexity), true

	case "TeamEngineer.createdAt":
		if e.complexity.TeamEngineer.CreatedAt == nil {
			break
		}

		return e.complexity.TeamEngineer.CreatedAt(childComplexity), true

	case "TeamEngineer.engineerID":
		if e.complexity.TeamEngineer.EngineerID == nil {
			break
		}

		return e.complexity.TeamEngineer.EngineerID(childComplexity), true

	case "TeamEngineer.teamID":
		if e.complexity.TeamEngineer.TeamID == nil {
			break
		}

		return e.complexity.TeamEngineer.TeamID(childComplexity), true

	case "Ticket.assignedToID":
		if e.complexity.Ticket.AssignedToID == nil {
			break
		}

		return e.complexity.Ticket.AssignedToID(childComplexity), true

	case "Ticket.completedAt":
		if e.complexity.Ticket.CompletedAt == nil {
			break
		}

		return e.complexity.Ticket.CompletedAt(childComplexity), true

	case "Ticket.createdAt":
		if e.complexity.Ticket.CreatedAt == nil {
			break
		}

		return e.complexity.Ticket.CreatedAt(childComplexity), true

	case "Ticket.description":
		if e.complexity.Ticket.Description == nil {
			break
		}

		return e.complexity.Ticket.Description(childComplexity), true

	case "Ticket.id":
		if e.complexity.Ticket.ID == nil {
			break
		}

		return e.complexity.Ticket.ID(childComplexity), true

	case "Ticket.priority":
		if e.complexity.Ticket.Priority == nil {
			break
		}

		return e.complexity.Ticket.Priority(childComplexity), true

	case "Ticket.projectID":
		if e.complexity.Ticket.ProjectID == nil {
			break
		}

		return e.complexity.Ticket.ProjectID(childComplexity), true

	case "Ticket.status":
		if e.complexity.Ticket.Status == nil {
			break
		}

		return e.complexity.Ticket.Status(childComplexity), true

	case "Ticket.title":
		if e.complexity.Ticket.Title == nil {
			break
		}

		return e.complexity.Ticket.Title(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputEmployeeFilter,
		ec.unmarshalInputEmployeeInput,
		ec.unmarshalInputLoginDetailsInput,
		ec.unmarshalInputNotificationFilter,
		ec.unmarshalInputProjectEmployeeInput,
		ec.unmarshalInputProjectFilter,
		ec.unmarshalInputProjectInput,
		ec.unmarshalInputProjectTeamInput,
		ec.unmarshalInputSortInput,
		ec.unmarshalInputTaskFilter,
		ec.unmarshalInputTaskInput,
		ec.unmarshalInputTeamEngineerInput,
		ec.unmarshalInputTeamFilter,
		ec.unmarshalInputTeamInput,
		ec.unmarshalInputTicketFilter,
		ec.unmarshalInputTicketInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../graphqls/directives.graphqls", Input: `# ----------- Directives -----------

directive @auth(role: Role!) on FIELD_DEFINITION

# Cache directive for caching responses
directive @cache(ttl: Int!) on FIELD_DEFINITION

# Rate limiting directive
directive @rateLimit(limit: Int!, window: String!) on FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../graphqls/filters.graphqls", Input: `# ----------- Filter Types -----------

# Base filter inputs for queries
input EmployeeFilter {
  name: String
  email: String
  role: Role
  active: Boolean
  projectAssignedID: Int
  createdAtAfter: DateTime
  createdAtBefore: DateTime
}

input ProjectFilter {
  name: String
  status: Status
  managerID: Int
  startDateAfter: DateTime
  startDateBefore: DateTime
  createdAtAfter: DateTime
  createdAtBefore: DateTime
}

input TaskFilter {
  title: String
  status: Status
  priority: Priority
  assignedToID: Int
  projectID: Int
  dueDateAfter: Date
  dueDateBefore: Date
  createdAtAfter: DateTime
  createdAtBefore: DateTime
}

input TicketFilter {
  title: String
  status: Status
  priority: Priority
  projectID: Int
  assignedToID: Int
  createdAtAfter: DateTime
  createdAtBefore: DateTime
}

input TeamFilter {
  name: String
  teamLeaderID: Int
  createdAtAfter: DateTime
  createdAtBefore: DateTime
}

input NotificationFilter {
  type: NotificationType
  read: Boolean
  createdAtAfter: DateTime
  createdAtBefore: DateTime
}

# Sorting inputs
input SortInput {
  field: String!
  direction: SortDirection!
}

enum SortDirection {
  ASC
  DESC
}

`, BuiltIn: false},
	{Name: "../graphqls/mutations.graphqls", Input: `# ----------- Mutations -----------

type Mutation {
  addEmployee(input: EmployeeInput!): Employee! @auth(role: ADMIN)
  updateEmployee(id: Int!, input: EmployeeInput!): Employee!
  deleteEmployee(id: Int!): Boolean!  @auth(role: ADMIN)

  addProject(input: ProjectInput!): Project!
  updateProject(id: Int!, input: ProjectInput!): Project!
  deleteProject(id: Int!): Boolean!

  addTeam(input: TeamInput!): Team!
  updateTeam(id: Int!, input: TeamInput!): Team!
  deleteTeam(id: Int!): Boolean!

  addTicket(input: TicketInput!): Ticket!
  updateTicket(id: Int!, input: TicketInput!): Ticket!
  deleteTicket(id: Int!): Boolean!

  addTask(input: TaskInput!): Task!
  updateTask(id: Int!, input: TaskInput!): Task!
  deleteTask(id: Int!): Boolean!

  addNotification(message: String!, employeeID: Int!, type: NotificationType): Notification!
  markNotificationRead(id: Int!): Boolean!


  addTeamEngineer(input: TeamEngineerInput!): TeamEngineer!
  removeTeamEngineer(input: TeamEngineerInput!): Boolean!
  
  addProjectTeam(input: ProjectTeamInput!): ProjectTeam!
  removeProjectTeam(input: ProjectTeamInput!): Boolean!
  
  addProjectEmployee(input: ProjectEmployeeInput!): ProjectEmployee!
  removeProjectEmployee(input: ProjectEmployeeInput!): Boolean!
  updateProjectEmployeeRole(input: ProjectEmployeeInput!): ProjectEmployee!
}
`, BuiltIn: false},
	{Name: "../graphqls/query.graphqls", Input: `# ----------- Queries -----------

type Query {

  employees(filter: EmployeeFilter): [Employee!]!
  employee(id: Int!): Employee
  signIn(email: String!, password: String!): Boolean!


  projects(filter: ProjectFilter): [Project!]!
  project(id: Int!): Project


  tasks(filter: TaskFilter): [Task!]!
  task(id: Int!): Task


  tickets(filter: TicketFilter): [Ticket!]!
  ticket(id: Int!): Ticket


  teams(filter: TeamFilter): [Team!]!
  team(id: Int!): Team

  
  notifications(employeeID: Int!, filter: NotificationFilter): [Notification!]!

  teamEngineers(teamID: Int!): [TeamEngineer!]!
  projectTeams(projectID: Int!): [ProjectTeam!]!
  projectEmployees(projectID: Int!): [ProjectEmployee!]!
  
  employeesByProject(projectID: Int!): [Employee!]!
  teamsByProject(projectID: Int!): [Team!]!
  engineersByTeam(teamID: Int!): [Employee!]!



}`, BuiltIn: false},
	{Name: "../graphqls/types.graphqls", Input: `# ----------- Scalars -----------
scalar Date
scalar DateTime

# ----------- Enums -----------
enum Role {
  ADMIN
  EMPLOYEE
  TL
  MANAGER
}

enum Status {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  ON_HOLD
  CANCELLED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum NotificationType {
  INFO
  WARNING
  ERROR
  SUCCESS
}


# ----------- Types -----------

type Employee {
  id: Int!
  name: String!
  email: String!
  role: Role!
  active: Boolean!
  projectAssignedID: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Project {
  id: Int!
  managerID: Int
  name: String!
  status: Status!
  description: String
  startDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Team {
  id: Int!
  teamLeaderID: Int
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Ticket {
  id: Int!
  projectID: Int!
  assignedToID: Int
  status: Status!
  title: String!
  description: String
  priority: Priority!
  createdAt: DateTime!
  completedAt: DateTime
}

type Task {
  id: Int!
  title: String!
  description: String
  assignedToID: Int
  projectID: Int
  dueDate: Date
  status: Status!
  priority: Priority!
  createdAt: DateTime!
  completedAt: DateTime
}

type Notification {
  id: Int!
  message: String!
  employeeID: Int!
  type: NotificationType!
  createdAt: DateTime!
  read: Boolean!
}

type TeamEngineer {
  teamID: Int!
  engineerID: Int!
  createdAt: DateTime!
}

type ProjectTeam {
  projectID: Int!
  teamID: Int!
  createdAt: DateTime!
}

type ProjectEmployee {
  projectID: Int!
  employeeID: Int!
  role: String!
  createdAt: DateTime!
}



# ----------- Inputs -----------


input LoginDetailsInput {
  username: String!
  password: String!
}

input EmployeeInput {
  name: String!
  role: Role!
  email: String!
  password: String!
  projectID: Int
}

input ProjectInput {
  name: String!
  managerID: Int
  teamIDs: [Int!]
  status: Status
  description: String
}

input TeamInput {
  name: String!
  teamLeaderID: Int
  description: String
  engineerIDs: [Int!]
}

input TicketInput {
  title: String!
  description: String
  projectID: Int!
  assignedToID: Int
  status: Status!
  priority: Priority
}

input TaskInput {
  title: String!
  description: String
  assignedToID: Int
  projectID: Int
  dueDate: Date
  status: Status!
  priority: Priority
}

input TeamEngineerInput {
  teamID: Int!
  engineerID: Int!
}

input ProjectTeamInput {
  projectID: Int!
  teamID: Int!
}

input ProjectEmployeeInput {
  projectID: Int!
  employeeID: Int!
  role: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
