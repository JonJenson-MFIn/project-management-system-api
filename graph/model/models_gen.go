// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type Employee struct {
	ID                int       `json:"id"`
	Name              string    `json:"name"`
	Email             string    `json:"email"`
	Role              Role      `json:"role"`
	Active            bool      `json:"active"`
	ProjectAssignedID *int      `json:"projectAssignedID,omitempty"`
	CreatedAt         time.Time `json:"createdAt"`
	UpdatedAt         time.Time `json:"updatedAt"`
}

type EmployeeFilter struct {
	Name              *string    `json:"name,omitempty"`
	Email             *string    `json:"email,omitempty"`
	Role              *Role      `json:"role,omitempty"`
	Active            *bool      `json:"active,omitempty"`
	ProjectAssignedID *int       `json:"projectAssignedID,omitempty"`
	CreatedAtAfter    *time.Time `json:"createdAtAfter,omitempty"`
	CreatedAtBefore   *time.Time `json:"createdAtBefore,omitempty"`
}

type EmployeeInput struct {
	Name      string `json:"name"`
	Role      Role   `json:"role"`
	Email     string `json:"email"`
	Password  string `json:"password"`
	ProjectID *int   `json:"projectID,omitempty"`
}

type LoginDetailsInput struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type Mutation struct {
}

type Notification struct {
	ID         int              `json:"id"`
	Message    string           `json:"message"`
	EmployeeID int              `json:"employeeID"`
	Type       NotificationType `json:"type"`
	CreatedAt  time.Time        `json:"createdAt"`
	Read       bool             `json:"read"`
}

type NotificationFilter struct {
	Type            *NotificationType `json:"type,omitempty"`
	Read            *bool             `json:"read,omitempty"`
	CreatedAtAfter  *time.Time        `json:"createdAtAfter,omitempty"`
	CreatedAtBefore *time.Time        `json:"createdAtBefore,omitempty"`
}

type Project struct {
	ID          int       `json:"id"`
	ManagerID   *int      `json:"managerID,omitempty"`
	Name        string    `json:"name"`
	Status      Status    `json:"status"`
	Description *string   `json:"description,omitempty"`
	StartDate   time.Time `json:"startDate"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

type ProjectEmployee struct {
	ProjectID  int       `json:"projectID"`
	EmployeeID int       `json:"employeeID"`
	Role       string    `json:"role"`
	CreatedAt  time.Time `json:"createdAt"`
}

type ProjectEmployeeInput struct {
	ProjectID  int    `json:"projectID"`
	EmployeeID int    `json:"employeeID"`
	Role       string `json:"role"`
}

type ProjectFilter struct {
	Name            *string    `json:"name,omitempty"`
	Status          *Status    `json:"status,omitempty"`
	ManagerID       *int       `json:"managerID,omitempty"`
	StartDateAfter  *time.Time `json:"startDateAfter,omitempty"`
	StartDateBefore *time.Time `json:"startDateBefore,omitempty"`
	CreatedAtAfter  *time.Time `json:"createdAtAfter,omitempty"`
	CreatedAtBefore *time.Time `json:"createdAtBefore,omitempty"`
}

type ProjectInput struct {
	Name        string  `json:"name"`
	ManagerID   *int    `json:"managerID,omitempty"`
	TeamIDs     []int   `json:"teamIDs,omitempty"`
	Status      *Status `json:"status,omitempty"`
	Description *string `json:"description,omitempty"`
}

type ProjectTeam struct {
	ProjectID int       `json:"projectID"`
	TeamID    int       `json:"teamID"`
	CreatedAt time.Time `json:"createdAt"`
}

type ProjectTeamInput struct {
	ProjectID int `json:"projectID"`
	TeamID    int `json:"teamID"`
}

type Query struct {
}

type SortInput struct {
	Field     string        `json:"field"`
	Direction SortDirection `json:"direction"`
}

type Task struct {
	ID           int        `json:"id"`
	Title        string     `json:"title"`
	Description  *string    `json:"description,omitempty"`
	AssignedToID *int       `json:"assignedToID,omitempty"`
	ProjectID    *int       `json:"projectID,omitempty"`
	DueDate      *string    `json:"dueDate,omitempty"`
	Status       Status     `json:"status"`
	Priority     Priority   `json:"priority"`
	CreatedAt    time.Time  `json:"createdAt"`
	CompletedAt  *time.Time `json:"completedAt,omitempty"`
}

type TaskFilter struct {
	Title           *string    `json:"title,omitempty"`
	Status          *Status    `json:"status,omitempty"`
	Priority        *Priority  `json:"priority,omitempty"`
	AssignedToID    *int       `json:"assignedToID,omitempty"`
	ProjectID       *int       `json:"projectID,omitempty"`
	DueDateAfter    *string    `json:"dueDateAfter,omitempty"`
	DueDateBefore   *string    `json:"dueDateBefore,omitempty"`
	CreatedAtAfter  *time.Time `json:"createdAtAfter,omitempty"`
	CreatedAtBefore *time.Time `json:"createdAtBefore,omitempty"`
}

type TaskInput struct {
	Title        string    `json:"title"`
	Description  *string   `json:"description,omitempty"`
	AssignedToID *int      `json:"assignedToID,omitempty"`
	ProjectID    *int      `json:"projectID,omitempty"`
	DueDate      *string   `json:"dueDate,omitempty"`
	Status       Status    `json:"status"`
	Priority     *Priority `json:"priority,omitempty"`
}

type Team struct {
	ID           int       `json:"id"`
	TeamLeaderID *int      `json:"teamLeaderID,omitempty"`
	Name         string    `json:"name"`
	Description  *string   `json:"description,omitempty"`
	CreatedAt    time.Time `json:"createdAt"`
	UpdatedAt    time.Time `json:"updatedAt"`
}

type TeamEngineer struct {
	TeamID     int       `json:"teamID"`
	EngineerID int       `json:"engineerID"`
	CreatedAt  time.Time `json:"createdAt"`
}

type TeamEngineerInput struct {
	TeamID     int `json:"teamID"`
	EngineerID int `json:"engineerID"`
}

type TeamFilter struct {
	Name            *string    `json:"name,omitempty"`
	TeamLeaderID    *int       `json:"teamLeaderID,omitempty"`
	CreatedAtAfter  *time.Time `json:"createdAtAfter,omitempty"`
	CreatedAtBefore *time.Time `json:"createdAtBefore,omitempty"`
}

type TeamInput struct {
	Name         string  `json:"name"`
	TeamLeaderID *int    `json:"teamLeaderID,omitempty"`
	Description  *string `json:"description,omitempty"`
	EngineerIDs  []int   `json:"engineerIDs,omitempty"`
}

type Ticket struct {
	ID           int        `json:"id"`
	ProjectID    int        `json:"projectID"`
	AssignedToID *int       `json:"assignedToID,omitempty"`
	Status       Status     `json:"status"`
	Title        string     `json:"title"`
	Description  *string    `json:"description,omitempty"`
	Priority     Priority   `json:"priority"`
	CreatedAt    time.Time  `json:"createdAt"`
	CompletedAt  *time.Time `json:"completedAt,omitempty"`
}

type TicketFilter struct {
	Title           *string    `json:"title,omitempty"`
	Status          *Status    `json:"status,omitempty"`
	Priority        *Priority  `json:"priority,omitempty"`
	ProjectID       *int       `json:"projectID,omitempty"`
	AssignedToID    *int       `json:"assignedToID,omitempty"`
	CreatedAtAfter  *time.Time `json:"createdAtAfter,omitempty"`
	CreatedAtBefore *time.Time `json:"createdAtBefore,omitempty"`
}

type TicketInput struct {
	Title        string    `json:"title"`
	Description  *string   `json:"description,omitempty"`
	ProjectID    int       `json:"projectID"`
	AssignedToID *int      `json:"assignedToID,omitempty"`
	Status       Status    `json:"status"`
	Priority     *Priority `json:"priority,omitempty"`
}

type NotificationType string

const (
	NotificationTypeInfo    NotificationType = "INFO"
	NotificationTypeWarning NotificationType = "WARNING"
	NotificationTypeError   NotificationType = "ERROR"
	NotificationTypeSuccess NotificationType = "SUCCESS"
)

var AllNotificationType = []NotificationType{
	NotificationTypeInfo,
	NotificationTypeWarning,
	NotificationTypeError,
	NotificationTypeSuccess,
}

func (e NotificationType) IsValid() bool {
	switch e {
	case NotificationTypeInfo, NotificationTypeWarning, NotificationTypeError, NotificationTypeSuccess:
		return true
	}
	return false
}

func (e NotificationType) String() string {
	return string(e)
}

func (e *NotificationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationType", str)
	}
	return nil
}

func (e NotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Priority string

const (
	PriorityLow    Priority = "LOW"
	PriorityMedium Priority = "MEDIUM"
	PriorityHigh   Priority = "HIGH"
	PriorityUrgent Priority = "URGENT"
)

var AllPriority = []Priority{
	PriorityLow,
	PriorityMedium,
	PriorityHigh,
	PriorityUrgent,
}

func (e Priority) IsValid() bool {
	switch e {
	case PriorityLow, PriorityMedium, PriorityHigh, PriorityUrgent:
		return true
	}
	return false
}

func (e Priority) String() string {
	return string(e)
}

func (e *Priority) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Priority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Priority", str)
	}
	return nil
}

func (e Priority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Priority) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Priority) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Role string

const (
	RoleAdmin    Role = "ADMIN"
	RoleEmployee Role = "EMPLOYEE"
	RoleTl       Role = "TL"
	RoleManager  Role = "MANAGER"
)

var AllRole = []Role{
	RoleAdmin,
	RoleEmployee,
	RoleTl,
	RoleManager,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleAdmin, RoleEmployee, RoleTl, RoleManager:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Role) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Role) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Status string

const (
	StatusNotStarted Status = "NOT_STARTED"
	StatusInProgress Status = "IN_PROGRESS"
	StatusCompleted  Status = "COMPLETED"
	StatusOnHold     Status = "ON_HOLD"
	StatusCancelled  Status = "CANCELLED"
)

var AllStatus = []Status{
	StatusNotStarted,
	StatusInProgress,
	StatusCompleted,
	StatusOnHold,
	StatusCancelled,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusNotStarted, StatusInProgress, StatusCompleted, StatusOnHold, StatusCancelled:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Status) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Status) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
